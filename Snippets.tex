% Generated by generate_pdf.py
\input{preamble.tex}
\begin{document}
\def\title{El Bicho}
\vspace{0.6cm}
\centering{\LARGE\textbf{El Bicho}}\\[0.5cm]
\centering{DondeEstasCR7}\\[0.5cm]
\centering{\includegraphics[width=5.5cm]{img/cr7.jpg}}\\[0.5cm]
\centering{06/02/2026}\\[0.2cm]
\tableofcontents
\newpage

\section{Algos}
\subsection{Binary Search}
\cppfile{build/sanitized_include/Binary Search.cpp}
\subsection{Fast Io}
\cppfile{build/sanitized_include/Fast IO.cpp}
\subsection{Sliding Window}
\cppfile{build/sanitized_include/Sliding Window.cpp}
\subsection{Tablas Y Cotas}
\cppfile{build/sanitized_include/Tablas_y_Cotas.cpp}
\subsection{Two Pointers}
\cppfile{build/sanitized_include/Two Pointers.cpp}

\section{Bit Manipulation}
Técnicas para manipular bits individuales y operaciones a nivel de bit. Incluye macros útiles para competencias de programación.

\subsection{Bits}
Macros esenciales para manipulación de bits: verificar potencias de 2, establecer/limpiar bits, contar bits, y operaciones con LSB/MSB.

\cppfile{build/sanitized_include/Bits.cpp}

\section{Combinatory}
\subsection{Combi Brute Sin Mod}
\cppfile{build/sanitized_include/Combi_brute_sin_MOD.cpp}
\subsection{Combinatory}
OJO: Es necesario usar binpow con MOD primo

\cppfile{build/sanitized_include/Combinatory.cpp}

\section{Data Structures}
\subsection{Fenwick Tree}
\cppfile{build/sanitized_include/Fenwick Tree.cpp}
\subsection{Find Two Numbers}
\cppfile{build/sanitized_include/Find_two_Numbers.cpp}
\subsection{Segment Tree}
\cppfile{build/sanitized_include/Segment_Tree.cpp}
\subsection{Sparse Table}
\cppfile{build/sanitized_include/Sparse Table.cpp}

\section{Dp}
\subsection{Digit Dp Pattern}
\cppfile{build/sanitized_include/Digit DP Pattern.cpp}
\subsection{Digit Dp}
\cppfile{build/sanitized_include/Digit DP.cpp}
\subsection{Edit Distance}
\cppfile{build/sanitized_include/Edit Distance.cpp}
\subsection{Knapsack}
\cppfile{build/sanitized_include/Knapsack.cpp}
\subsection{Lcs}
\cppfile{build/sanitized_include/LCS.cpp}

\section{Geometry}
\subsection{2D Geometry}
\textbf{Cookbook Geometría 2D} - Operaciones con Puntos, Vectores, Líneas y Polígonos

\vspace{0.3cm}
\textbf{PROBLEMAS TÍPICOS Y SUS SOLUCIONES}

\begin{itemize}
    \item \textbf{¿Un segmento toca un rectángulo?}
    
    Construir 4 lados del rectángulo como \texttt{Line}, usar \texttt{segIntersect(seg, lado\_i)} para $i = 1..4$, y verificar con \texttt{between}/extremos dentro para cubrir el caso ``segmento completamente dentro''.
    
    \textit{Funciones clave:} \texttt{segIntersect}, \texttt{between}, \texttt{Point/Line}.
    
    \item \textbf{¿Dos segmentos se cruzan?}
    
    Usar \texttt{segIntersect(l1, l2)} si contar colineales y tocar endpoints, o \texttt{segStrictlyIntersect(l1, l2)} si solo quieres cruce estricto.
    
    \item \textbf{Distancia mínima entre dos segmentos}
    
    \texttt{Real d = segDist(l1, l2);} Si $d = 0$ entonces se tocan o cruzan.
    
    \item \textbf{Distancia mínima de un punto a un segmento}
    
    \texttt{Real d = pointToSegDist(p, seg);}
    
    \item \textbf{Distancia mínima de un punto a una recta infinita}
    
    \texttt{Real d = pointToLineDist(p, line);}
    
    \item \textbf{¿Punto dentro de un polígono cualquiera?}
    
    \texttt{bool inside = pointInPoly(p, poly);}
    
    \item \textbf{Área de un polígono (ordenado CCW o CW)}
    
    \texttt{T twice = area(poly); Real A = fabsl((Real)twice) / 2.0;}
    
    \item \textbf{¿Cuándo un triángulo es degenerado?}
    
    Un triángulo con vértices $a, b, c$ es degenerado (área = 0) si: (1) sus puntos son colineales \texttt{sign(cross(b-a, c-a)) == 0}, o (2) con lados $a, b, c$, falla la desigualdad triangular estricta ($a+b > c, a+c > b, b+c > a$), i.e., $a+b = c$ (se aplana).
    
    \item \textbf{¿Punto sobre el borde de un polígono?}
    
    Recorrer lados $[i, i+1]$, verificar si \texttt{pointOnSeg(p, Line(ai, aj))}.
    
    \item \textbf{¿Dos rectas infinitas se cruzan? Dame el punto}
    
    Primero verificar que no sean paralelas: \texttt{sign(cross(direction(l1), direction(l2))) != 0}, luego \texttt{P<Real> inter = lineIntersection(l1, l2);}
    
    \item \textbf{Ordenar vectores/puntos por ángulo alrededor del origen}
    
    \texttt{sort(v.begin(), v.end(), polar<i64>);} o usar lambda con \texttt{up()} y \texttt{cross()}.
    
    \item \textbf{Vector normal a un segmento}
    
    \texttt{P<T> d = direction(seg); P<T> n = rotate90(d);} (normal 90° CCW) o \texttt{P<Real> nu = normal(d);} (normal unitaria).
    
    \item \textbf{Detectar si un punto está a la izquierda/derecha de un borde}
    
    \texttt{int s = side(p, a, b);} donde $s > 0$ izquierda (CCW), $s < 0$ derecha (CW), $s = 0$ colineal.
    
    \item \textbf{Clasificar orientación de un polígono}
    
    \texttt{T twice = area(poly);} Si \texttt{twice > 0} es CCW, si \texttt{twice < 0} es CW.
    
    \item \textbf{Reflexión de un punto respecto a una recta}
    
    \texttt{P<Real> pr = reflection(p, line);}
    
    \item \textbf{Proyección de un punto sobre una recta}
    
    \texttt{P<Real> proj = projection(p, line);}
    
    \item \textbf{Intersección de rayo con segmento}
    
    \texttt{rayIntersect(rayo1, rayo2)} si ambos modelados como \texttt{Line} con origen en \texttt{l.l[0]} y dirección \texttt{l.l[1]-l.l[0]}. Para rayo vs segmento, combinar con \texttt{segIntersect} o rediseñar con \texttt{side()} y \texttt{dot()}.
    
    \item \textbf{Rotar un punto/vector alrededor del origen}
    
    \texttt{P<Real> rotado = rotate(p, angulo\_en\_radianes);} Para 90° CCW rápido: \texttt{rotate90(p);}
    
    \item \textbf{Calcular ángulo de un vector respecto al eje X}
    
    \texttt{Real ang = angle(p);} devuelve \texttt{atan2(p.y, p.x)} en radianes.
\end{itemize}

\vspace{0.3cm}
\textbf{TIPS IMPORTANTES}
\begin{itemize}
    \item Usa \texttt{Point = P<i64>} para coords enteras, evita overflow en \texttt{cross/dot}
    \item Usa \texttt{P<Real>} (long double) para resultados con decimales (distancias, intersecciones)
    \item \texttt{EPS = 1e-9} para comparaciones de flotantes
    \item \texttt{sign()} y \texttt{cmp()} manejan tolerancia automáticamente
    \item Para convex hull y polígonos, mantén puntos en sentido CCW
    \item Verifica casos especiales: colineales, segmentos degenerados (mismo punto)
    \item Al leer entrada: \texttt{Point p; cin >\hspace{0pt}> p;} (operador sobrecargado)
\end{itemize}

\cppfile{build/sanitized_include/2D_Geometry.cpp}
\subsection{Convex Hull}
\cppfile{build/sanitized_include/Convex Hull.cpp}

\section{Graph}
Algoritmos de grafos: DFS, BFS, componentes fuertemente conexas, y otras estructuras de datos para problemas de grafos.

\subsection{Bellman Ford}
\cppfile{build/sanitized_include/Bellman Ford.cpp}
\subsection{Bfs}
\cppfile{build/sanitized_include/BFS.cpp}
\subsection{Bipartite}
\cppfile{build/sanitized_include/Bipartite.cpp}
\subsection{Dfs}
\cppfile{build/sanitized_include/DFS.cpp}
\subsection{Dfs 2D}
\cppfile{build/sanitized_include/DFS_2D.cpp}
\subsection{Dijkstra}
\cppfile{build/sanitized_include/Dijkstra.cpp}
\subsection{Disjoint Set Union Dsu}
\cppfile{build/sanitized_include/Disjoint Set Union DSU.cpp}
\subsection{Floyd Warshall}
\cppfile{build/sanitized_include/Floyd Warshall.cpp}
\subsection{Kruskal}
\cppfile{build/sanitized_include/Kruskal.cpp}
\subsection{Lowest Common Ancestor Lca}
\cppfile{build/sanitized_include/Lowest Common Ancestor LCA.cpp}
\subsection{Prim}
\cppfile{build/sanitized_include/Prim.cpp}
\subsection{Scc}
Algoritmo de Tarjan para encontrar componentes fuertemente conexas (SCC) en un grafo dirigido.

\cppfile{build/sanitized_include/SCC.cpp}
\subsection{Topo Sort Dfs}
\cppfile{build/sanitized_include/Topo_Sort_DFS.cpp}
\subsection{Topo Sort Kahns Bfs}
\cppfile{build/sanitized_include/Topo_Sort_Kahns_BFS.cpp}

\section{Manhattan Distance}
\subsection{Farthest Pair Of Points}
\cppfile{build/sanitized_include/Farthest_pair_of_points.cpp}
\subsection{Nearest Neighbor In Each Octant}
\cppfile{build/sanitized_include/Nearest_Neighbor_in_each_Octant.cpp}

\section{Number Theory}
\subsection{Euler Toliente}
\cppfile{build/sanitized_include/Euler_Toliente.cpp}
\subsection{Gcd Lcm}
\cppfile{build/sanitized_include/GCD_LCM.cpp}
\subsection{Number Theory}
\cppfile{build/sanitized_include/Number_Theory.cpp}
\subsection{Phi Euler}
Phi(n) = contar la cantidad de numero coprimos entre 1 a n

\cppfile{build/sanitized_include/Phi_Euler.cpp}
\subsection{Potenciacion Binaria}
\cppfile{build/sanitized_include/Potenciacion_Binaria.cpp}
\subsection{Sieve}
\cppfile{build/sanitized_include/Sieve.cpp}
\subsection{Sieve Bitset}
\cppfile{build/sanitized_include/Sieve_bitset.cpp}
\subsection{Sum Of Divisors}
\cppfile{build/sanitized_include/Sum_of_Divisors.cpp}

\section{Numerical Methods}
\subsection{Calculating The Determinant Of A Matrix By Gauss}
\cppfile{build/sanitized_include/Calculating the determinant of a matrix by Gauss.cpp}
\subsection{Gauss Method For Solving System Of Linear Equations}
\cppfile{build/sanitized_include/Gauss method for solving system of linear equations.cpp}
\subsection{Gauss Solving Modular Slae}
\cppfile{build/sanitized_include/Gauss Solving modular SLAE.cpp}
\subsection{Integration By Simpson'S Formula}
\cppfile{build/sanitized_include/Integration by Simpson's formula.cpp}

\section{String}
\subsection{Kmp}
\cppfile{build/sanitized_include/KMP.cpp}
\subsection{Trie}
\cppfile{build/sanitized_include/Trie.cpp}
\subsection{Z Algorithm}
\cppfile{build/sanitized_include/Z Algorithm.cpp}

\end{document}
